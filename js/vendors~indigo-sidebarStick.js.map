{"version":3,"sources":["webpack:///./node_modules/sticky-sidebar-v2/src/sticky-sidebar.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC,iBAAiB,OAAO;AACxB;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D,gCAAgC;AAC3F,2DAA2D,gCAAgC;;AAE3F;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2C;;AAEA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA,mE;AACA,2C;;AAEA,WAAW;AACX;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA,W;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB;AAClB;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA,4CAA4C,yBAAyB;AACrE,4CAA4C;AAC5C,kDAAkD;;AAElD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD,eAAe;AACnE,oDAAoD,eAAe;;AAEnE;AACA;;AAEA;;AAEA,0BAA0B,SAAS;;AAEnC,4BAA4B;AAC5B,4BAA4B;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,O;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH,EAAiB,4EAAa,EAAC;;AAE/B;AACA;AACA,uC","file":"vendors~indigo-sidebarStick.js","sourcesContent":["/**\n * Sticky Sidebar v2 JavaScript Plugin.\n * @version 1.0.1\n * @author Ã˜ystein Blixhavn <oystein@blixhavn.no>\n * @license The MIT License (MIT)\n */\nconst StickySidebar = (() => {\n  \n    // ---------------------------------\n    // # Define Constants\n    // ---------------------------------\n    //\n    const EVENT_KEY = '.stickySidebar';\n    const VERSION   = '1.0.1';\n  \n    const DEFAULTS = {\n      /**\n       * Additional top spacing of the element when it becomes sticky.\n       * @type {Numeric|Function}\n       */\n      topSpacing: 0,\n  \n      /**\n       * Additional bottom spacing of the element when it becomes sticky.\n       * @type {Numeric|Function}\n       */\n      bottomSpacing: 0,\n  \n      /**\n       * Container sidebar selector to know what the beginning and end of sticky element.\n       * @type {String|False}\n       */\n      containerSelector: false,\n\n      /**\n       * Parent element where the scrolling happens.\n       */\n      scrollContainer: false,\n  \n      /**\n       * Inner wrapper selector.\n       * @type {String}\n       */\n      innerWrapperSelector: '.inner-wrapper-sticky',\n  \n      /**\n       * The name of CSS class to apply to elements when they have become stuck.\n       * @type {String|False}\n       */\n      stickyClass: 'is-affixed',\n  \n      /**\n       * Detect when sidebar and its container change height so re-calculate their dimensions.\n       * @type {Boolean}\n       */\n      resizeSensor: true,\n  \n      /**\n       * The sidebar returns to its normal position if its width below this value.\n       * @type {Numeric}\n       */\n      minWidth: false\n    };\n  \n    // ---------------------------------\n    // # Class Definition\n    // ---------------------------------\n    //\n    /**\n     * Sticky Sidebar Class.\n     * @public\n     */\n    class StickySidebar{\n  \n      /**\n       * Sticky Sidebar Constructor.\n       * @constructor\n       * @param {HTMLElement|String} sidebar - The sidebar element or sidebar selector.\n       * @param {Object} options - The options of sticky sidebar.\n       */\n      constructor(sidebar, options = {}){\n        this.options = StickySidebar.extend(DEFAULTS, options);\n  \n        // Sidebar element query if there's no one, throw error.\n        this.sidebar = ('string' === typeof sidebar ) ? document.querySelector(sidebar) : sidebar;\n        if( 'undefined' === typeof this.sidebar )\n          throw new Error(\"There is no specific sidebar element.\");\n  \n        this.sidebarInner = false;\n        this.container = this.sidebar.parentElement;\n  \n        // Current Affix Type of sidebar element.\n        this.affixedType = 'STATIC';\n        this.direction = 'down';\n        this.support = { \n          transform:   false,\n          transform3d: false\n        };\n  \n        this._initialized = false;\n        this._reStyle = false;\n        this._breakpoint = false;\n        \n        // Dimensions of sidebar, container and screen viewport.\n        this.dimensions = {\n          translateY: 0,\n          maxTranslateY: 0,\n          topSpacing: 0,\n          lastTopSpacing: 0,\n          bottomSpacing: 0,\n          lastBottomSpacing: 0,\n          sidebarHeight: 0,\n          sidebarWidth: 0,\n          containerTop: 0,\n          containerHeight: 0,\n          viewportHeight: 0,\n          viewportTop: 0, \n          lastViewportTop: 0,\n        };\n  \n        // Bind event handlers for referencability.\n        ['handleEvent'].forEach( (method) => {\n          this[method] = this[method].bind(this);\n        });\n  \n        // Initialize sticky sidebar for first time.\n        this.initialize();\n      }\n  \n      /**\n       * Initializes the sticky sidebar by adding inner wrapper, define its container, \n       * min-width breakpoint, calculating dimensions, adding helper classes and inline style.\n       * @private\n       */\n      initialize(){\n        this._setSupportFeatures();\n        \n        // Get sticky sidebar inner wrapper, if not found, will create one.\n        if( this.options.innerWrapperSelector ){\n          this.sidebarInner = this.sidebar.querySelector(this.options.innerWrapperSelector);\n  \n          if( null === this.sidebarInner )\n            this.sidebarInner = false;\n        }\n        \n        if( ! this.sidebarInner ){\n          let wrapper = document.createElement('div');\n          wrapper.setAttribute('class', 'inner-wrapper-sticky');\n          this.sidebar.appendChild(wrapper);\n  \n          while( this.sidebar.firstChild != wrapper )\n            wrapper.appendChild(this.sidebar.firstChild);\n  \n          this.sidebarInner = this.sidebar.querySelector('.inner-wrapper-sticky');\n        }\n  \n        // Container wrapper of the sidebar.\n        if( this.options.containerSelector ){\n          let containers = document.querySelectorAll(this.options.containerSelector);\n          containers = Array.prototype.slice.call(containers);\n  \n          containers.forEach((container, item) => {\n            if( ! container.contains(this.sidebar) ) return;\n            this.container = container;\n          });\n  \n          if( ! containers.length )\n            throw new Error(\"The container does not contains on the sidebar.\");\n        }\n\n        // Get scroll container, if provided\n        this.scrollContainer = this.options.scrollContainer ? document.querySelector(this.options.scrollContainer) : undefined;\n        \n        // If top/bottom spacing is not function parse value to integer.\n        if( 'function' !== typeof this.options.topSpacing )\n          this.options.topSpacing = parseInt(this.options.topSpacing) || 0;\n  \n        if( 'function' !== typeof this.options.bottomSpacing )\n          this.options.bottomSpacing = parseInt(this.options.bottomSpacing) || 0;\n            \n        // Breakdown sticky sidebar if screen width below `options.minWidth`.\n        this._widthBreakpoint();\n  \n        // Calculate dimensions of sidebar, container and viewport.\n        this.calcDimensions();\n  \n        // Affix sidebar in proper position.\n        this.stickyPosition();\n  \n        // Bind all events.\n        this.bindEvents();\n        \n        // Inform other properties the sticky sidebar is initialized.\n        this._initialized = true;\n      }\n  \n      /**\n       * Bind all events of sticky sidebar plugin.\n       * @protected\n       */\n      bindEvents(){\n        this.eventTarget = this.scrollContainer ? this.scrollContainer : window;\n\n        this.eventTarget.addEventListener('resize', this, { passive: true, capture: false });\n        this.eventTarget.addEventListener('scroll', this, { passive: true, capture: false });\n  \n        this.sidebar.addEventListener('update' + EVENT_KEY, this);\n  \n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\n          new ResizeSensor(this.sidebarInner, this.handleEvent);\n          new ResizeSensor(this.container, this.handleEvent);\n        }\n      }\n  \n      /**\n       * Handles all events of the plugin.\n       * @param {Object} event - Event object passed from listener.\n       */\n      handleEvent(event){\n        this.updateSticky(event);\n      }\n  \n      /**\n       * Calculates dimensions of sidebar, container and screen viewpoint\n       * @public\n       */\n      calcDimensions(){\n        if( this._breakpoint ) return;\n        var dims = this.dimensions;\n  \n        // Container of sticky sidebar dimensions.\n        dims.containerTop    = StickySidebar.offsetRelative(this.container).top;\n        dims.containerHeight = this.container.clientHeight;\n        dims.containerBottom = dims.containerTop + dims.containerHeight;\n  \n        // Sidebar dimensions.\n        dims.sidebarHeight = this.sidebarInner.offsetHeight;\n        dims.sidebarWidth  = this.sidebarInner.offsetWidth;\n        \n        // Screen viewport dimensions.\n        dims.viewportHeight = window.innerHeight;\n\n        // Maximum sidebar translate Y.\n        dims.maxTranslateY = dims.containerHeight - dims.sidebarHeight;\n\n        this._calcDimensionsWithScroll();\n      }\n  \n      /**\n       * Some dimensions values need to be up-to-date when scrolling the page.\n       * @private\n       */\n      _calcDimensionsWithScroll(){\n        var dims = this.dimensions;\n  \n        dims.sidebarLeft = StickySidebar.offsetRelative(this.sidebar).left;\n\n        if (this.scrollContainer) {\n          dims.viewportTop = this.scrollContainer.scrollTop;\n          dims.viewportLeft = this.scrollContainer.scrollLeft;\n        } else {\n          dims.viewportTop = document.documentElement.scrollTop || document.body.scrollTop;\n          dims.viewportLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        }\n        dims.viewportBottom = dims.viewportTop + dims.viewportHeight;\n  \n        dims.topSpacing    = this.options.topSpacing;\n        dims.bottomSpacing = this.options.bottomSpacing;\n  \n        if( 'function' === typeof dims.topSpacing )\n            dims.topSpacing = parseInt(dims.topSpacing(this.sidebar)) || 0;\n  \n        if( 'function' === typeof dims.bottomSpacing )\n            dims.bottomSpacing = parseInt(dims.bottomSpacing(this.sidebar)) || 0;\n        \n        if( 'VIEWPORT-TOP' === this.affixedType ){\n          // Adjust translate Y in the case decrease top spacing value.\n          if( dims.topSpacing < dims.lastTopSpacing ){\n            dims.translateY += dims.lastTopSpacing - dims.topSpacing;\n            this._reStyle = true; \n          }\n        } else if( 'VIEWPORT-BOTTOM' === this.affixedType ){\n          // Adjust translate Y in the case decrease bottom spacing value.\n          if( dims.bottomSpacing < dims.lastBottomSpacing ){\n            dims.translateY += dims.lastBottomSpacing - dims.bottomSpacing;\n            this._reStyle = true;\n          }\n        }\n        \n        dims.lastTopSpacing    = dims.topSpacing;\n        dims.lastBottomSpacing = dims.bottomSpacing;\n      }\n      \n      /**\n       * Determine whether the sidebar is bigger than viewport.\n       * @public\n       * @return {Boolean}\n       */\n      isSidebarFitsViewport(){\n        let dims = this.dimensions;\n        let offset = this.scrollDirection === 'down' ? dims.lastBottomSpacing : dims.lastTopSpacing;\n        return this.dimensions.sidebarHeight + offset < this.dimensions.viewportHeight;\n      }\n  \n      /**\n       * Observe browser scrolling direction top and down.\n       */\n      observeScrollDir(){\n        var dims = this.dimensions;\n        if( dims.lastViewportTop === dims.viewportTop ) return;\n  \n        var furthest = 'down' === this.direction ? Math.min : Math.max;\n        \n        // If the browser is scrolling not in the same direction.\n        if( dims.viewportTop === furthest(dims.viewportTop, dims.lastViewportTop) )\n          this.direction = 'down' === this.direction ?  'up' : 'down';\n      }\n  \n      /**\n       * Gets affix type of sidebar according to current scroll top and scrolling direction.\n       * @public\n       * @return {String|False} - Proper affix type.\n       */\n      getAffixType(){\n        this._calcDimensionsWithScroll();\n        var dims = this.dimensions;\n        var colliderTop = dims.viewportTop + dims.topSpacing;\n        var affixType = this.affixedType;\n\n       if( colliderTop <= dims.containerTop || dims.containerHeight <= dims.sidebarHeight ){\n          dims.translateY = 0;\n          affixType = 'STATIC';\n        } else {\n          affixType = ( 'up' === this.direction ) ? \n            this._getAffixTypeScrollingUp() : this._getAffixTypeScrollingDown();\n        }\n\n        // Make sure the translate Y is not bigger than container height.\n        dims.translateY = Math.max(0, dims.translateY);\n        dims.translateY = Math.min(dims.containerHeight, dims.translateY);\n        dims.translateY = Math.round(dims.translateY);\n  \n        dims.lastViewportTop = dims.viewportTop;\n        return affixType;\n      }\n\n      /**\n       * Get affix type while scrolling down.\n       * @private\n       * @return {String} - Proper affix type of scrolling down direction.\n       */\n      _getAffixTypeScrollingDown(){\n        var dims = this.dimensions;\n        var sidebarBottom = dims.sidebarHeight + dims.containerTop;\n        var colliderTop = dims.viewportTop + dims.topSpacing;\n        var colliderBottom = dims.viewportBottom - dims.bottomSpacing;\n        var affixType = this.affixedType;\n        \n        if( this.isSidebarFitsViewport() ){\n          if( dims.sidebarHeight + colliderTop >= dims.containerBottom ){\n            dims.translateY = dims.containerBottom - sidebarBottom;\n            affixType = 'CONTAINER-BOTTOM'; \n\n          } else if( colliderTop >= dims.containerTop ){\n            dims.translateY = colliderTop - dims.containerTop;\n            affixType = 'VIEWPORT-TOP';\n          }\n        } else {\n          if( dims.containerBottom <= colliderBottom ){\n            dims.translateY = dims.containerBottom - sidebarBottom; \n            affixType = 'CONTAINER-BOTTOM';    \n\n          } else if( sidebarBottom + dims.translateY <= colliderBottom ){\n            dims.translateY = colliderBottom - sidebarBottom;\n            affixType = 'VIEWPORT-BOTTOM';\n          \n          } else if( dims.containerTop + dims.translateY <= colliderTop &&\n            (0 !== dims.translateY && dims.maxTranslateY !== dims.translateY) ){\n            affixType = 'VIEWPORT-UNBOTTOM';\n          }\n        }\n\n        return affixType;\n      }\n      \n      /**\n       * Get affix type while scrolling up.\n       * @private\n       * @return {String} - Proper affix type of scrolling up direction.\n       */\n      _getAffixTypeScrollingUp(){\n        var dims = this.dimensions;\n        var sidebarBottom = dims.sidebarHeight + dims.containerTop;\n        var colliderTop = dims.viewportTop + dims.topSpacing;\n        var colliderBottom = dims.viewportBottom - dims.bottomSpacing;\n        var affixType = this.affixedType;\n\n        if( colliderTop <= dims.translateY + dims.containerTop ){\n          dims.translateY = colliderTop - dims.containerTop;\n          affixType = 'VIEWPORT-TOP';\n        \n        } else if( dims.containerBottom <= colliderBottom ){\n          dims.translateY = dims.containerBottom - sidebarBottom;\n          affixType = 'CONTAINER-BOTTOM';\n\n        } else if( ! this.isSidebarFitsViewport() ){\n\n          if( dims.containerTop <= colliderTop && \n              (0 !== dims.translateY && dims.maxTranslateY !== dims.translateY) ){\n            affixType = 'VIEWPORT-UNBOTTOM';\n          } \n        }\n\n        return affixType;\n      }\n\n      /**\n       * Gets inline style of sticky sidebar wrapper and inner wrapper according \n       * to its affix type.\n       * @private\n       * @param {String} affixType - Affix type of sticky sidebar.\n       * @return {Object}\n       */\n      _getStyle(affixType){\n        if( 'undefined' === typeof affixType ) return;\n  \n        var style = {inner: {}, outer: {}};\n        var dims = this.dimensions;\n  \n        switch( affixType ){\n          case 'VIEWPORT-TOP':\n            style.inner = {position: 'fixed', top: dims.topSpacing,\n                  left: dims.sidebarLeft - dims.viewportLeft, width: dims.sidebarWidth};\n            break;\n          case 'VIEWPORT-BOTTOM':\n            style.inner = {position: 'fixed', top: 'auto', left: dims.sidebarLeft,\n                  bottom: dims.bottomSpacing, width: dims.sidebarWidth};\n            break;\n          case 'CONTAINER-BOTTOM':\n          case 'VIEWPORT-UNBOTTOM':\n            let translate = this._getTranslate(0, dims.translateY + 'px');\n            \n            if( translate )\n              style.inner = {transform: translate};\n            else \n              style.inner = {position: 'absolute', top: dims.translateY, width: dims.sidebarWidth};\n            break;\n        }\n        \n        switch( affixType ){\n          case 'VIEWPORT-TOP':\n          case 'VIEWPORT-BOTTOM':\n          case 'VIEWPORT-UNBOTTOM':\n          case 'CONTAINER-BOTTOM':\n            style.outer = {height: dims.sidebarHeight, position: 'relative'};\n            break;\n        }\n  \n        style.outer = StickySidebar.extend({height: '', position: ''}, style.outer);\n        style.inner = StickySidebar.extend({position: 'relative', top: '', left: '',\n            bottom: '', width: '',  transform: ''}, style.inner);\n  \n        return style;\n      }\n     \n      /**\n       * Cause the sidebar to be sticky according to affix type by adding inline\n       * style, adding helper class and trigger events.\n       * @function\n       * @protected\n       * @param {string} force - Update sticky sidebar position by force.\n       */\n      stickyPosition(force){\n        if( this._breakpoint ) return;\n  \n        force = this._reStyle || force || false;\n        \n        var offsetTop = this.options.topSpacing;\n        var offsetBottom = this.options.bottomSpacing;\n  \n        var affixType = this.getAffixType();\n        var style = this._getStyle(affixType);\n        \n        if( (this.affixedType != affixType || force) && affixType ){\n          let affixEvent = 'affix.' + affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\n          StickySidebar.eventTrigger(this.sidebar, affixEvent);\n  \n          if( 'STATIC' === affixType )\n            StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\n          else\n            StickySidebar.addClass(this.sidebar, this.options.stickyClass);\n          \n          for( let key in style.outer ){\n            let unit = ('number' === typeof style.outer[key]) ? 'px' : '';\n            this.sidebar.style[key] = style.outer[key] + unit;\n          }\n  \n          for( let key in style.inner ){\n            let unit = ('number' === typeof style.inner[key]) ? 'px' : '';\n            this.sidebarInner.style[key] = style.inner[key] + unit;\n          }\n          \n          let affixedEvent = 'affixed.'+ affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\n          StickySidebar.eventTrigger(this.sidebar, affixedEvent);\n        } else {\n          if( this._initialized ) this.sidebarInner.style.left = style.inner.left;\n        }\n  \n        this.affixedType = affixType;\n      }\n  \n      /**\n       * Breakdown sticky sidebar when window width is below `options.minWidth` value.\n       * @protected\n       */\n      _widthBreakpoint(){\n  \n        if( window.innerWidth <= this.options.minWidth ){\n          this._breakpoint = true;\n          this.affixedType = 'STATIC';\n  \n          this.sidebar.removeAttribute('style');\n          StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\n          this.sidebarInner.removeAttribute('style');\n        } else {\n          this._breakpoint = false;\n        }\n      }\n  \n      /**\n       * Switches between functions stack for each event type, if there's no \n       * event, it will re-initialize sticky sidebar.\n       * @public\n       */\n      updateSticky(event = {}){\n        if( this._running ) return;\n        this._running = true;\n  \n        ((eventType) => {\n          requestAnimationFrame(() => {\n            switch( eventType ){\n              // When browser is scrolling and re-calculate just dimensions\n              // within scroll. \n              case 'scroll':\n                this._calcDimensionsWithScroll();\n                this.observeScrollDir();\n                this.stickyPosition();\n                break;\n  \n              // When browser is resizing or there's no event, observe width\n              // breakpoint and re-calculate dimensions.\n              case 'resize':\n              default: \n                this._widthBreakpoint();\n                this.calcDimensions();\n                this.stickyPosition(true);\n                break;\n            }\n            this._running = false;\n          });\n        })(event.type);\n      }\n  \n      /**\n       * Set browser support features to the public property.\n       * @private\n       */\n      _setSupportFeatures(){\n        var support = this.support;\n  \n        support.transform = StickySidebar.supportTransform();\n        support.transform3d = StickySidebar.supportTransform(true);\n      }\n  \n      /**\n       * Get translate value, if the browser supports transfrom3d, it will adopt it.\n       * and the same with translate. if browser doesn't support both return false.\n       * @param {Number} y - Value of Y-axis.\n       * @param {Number} x - Value of X-axis.\n       * @param {Number} z - Value of Z-axis.\n       * @return {String|False}\n       */\n      _getTranslate(y = 0, x = 0, z = 0){\n        if( this.support.transform3d ) return 'translate3d(' + y +', '+ x +', '+ z +')';\n        else if( this.support.translate ) return 'translate('+ y +', '+ x +')';\n        else return false;\n      }\n  \n      /**\n       * Destroy sticky sidebar plugin.\n       * @public\n       */\n      destroy(){\n        window.removeEventListener('resize', this, {capture: false});\n        window.removeEventListener('scroll', this, {capture: false});\n  \n        this.sidebar.classList.remove(this.options.stickyClass);\n        this.sidebar.style.minHeight = '';\n  \n        this.sidebar.removeEventListener('update' + EVENT_KEY, this);\n  \n        var styleReset = {inner: {}, outer: {}};\n  \n        styleReset.inner = {position: '', top: '', left: '', bottom: '', width: '',  transform: ''};\n        styleReset.outer = {height: '', position: ''};\n  \n        for( let key in styleReset.outer )\n          this.sidebar.style[key] = styleReset.outer[key];\n  \n        for( let key in styleReset.inner )\n          this.sidebarInner.style[key] = styleReset.inner[key];\n  \n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\n          ResizeSensor.detach(this.sidebarInner, this.handleEvent);\n          ResizeSensor.detach(this.container, this.handleEvent);\n        }\n      }\n  \n      /**\n       * Determine if the browser supports CSS transform feature.\n       * @function\n       * @static\n       * @param {Boolean} transform3d - Detect transform with translate3d.\n       * @return {String}\n       */\n      static supportTransform(transform3d){\n        var result = false,\n            property = (transform3d) ? 'perspective' : 'transform',\n            upper = property.charAt(0).toUpperCase() + property.slice(1),\n            prefixes = ['Webkit', 'Moz', 'O', 'ms'],\n            support = document.createElement('support'),\n            style = support.style;\n  \n        (property + ' ' + prefixes.join(upper + ' ') + upper).split(' ').forEach(function(property, i) {\n          if (style[property] !== undefined) {\n            result = property;\n            return false;\n          }\n        });\n        return result;\n      }\n  \n      /**\n       * Trigger custom event.\n       * @static\n       * @param {DOMObject} element - Target element on the DOM.\n       * @param {String} eventName - Event name.\n       * @param {Object} data - \n       */\n      static eventTrigger(element, eventName, data){\n        try{\n          var event = new CustomEvent(eventName, {detail: data});\n        } catch(e){\n          var event = document.createEvent('CustomEvent');\n          event.initCustomEvent(eventName, true, true, data);\n        }\n        element.dispatchEvent(event);\n      }\n  \n      /**\n       * Extend options object with defaults.\n       * @function\n       * @static\n       */\n      static extend(defaults, options){\n        var results = {};\n        for( let key in defaults ){\n          if( 'undefined' !== typeof options[key] ) results[key] = options[key];\n          else results[key] = defaults[key];\n        }\n        return results;\n      }\n  \n      /**\n       * Get current coordinates left and top of specific element.\n       * @static\n       */\n      static offsetRelative(element){\n        var result = {left: 0, top: 0};\n\n        do{\n          let offsetTop = element.offsetTop;\n          let offsetLeft = element.offsetLeft;\n  \n          if( ! isNaN(offsetTop) )\n            result.top += offsetTop;\n  \n          if( ! isNaN(offsetLeft) )\n            result.left += offsetLeft;\n\n          element = ( 'BODY' === element.tagName ) ?\n                      element.parentElement : element.offsetParent;\n        } while(element)\n        return result;\n      }\n  \n      /**\n       * Add specific class name to specific element.\n       * @static \n       * @param {ObjectDOM} element \n       * @param {String} className \n       */\n      static addClass(element, className){\n        if( ! StickySidebar.hasClass(element, className) ){\n          if (element.classList)\n            element.classList.add(className);\n          else\n            element.className += ' ' + className;\n        }\n      }\n      \n      /**\n       * Remove specific class name to specific element\n       * @static\n       * @param {ObjectDOM} element \n       * @param {String} className \n       */\n      static removeClass(element, className){\n        if( StickySidebar.hasClass(element, className) ){\n          if (element.classList)\n            element.classList.remove(className);\n          else\n            element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        }\n      }\n\n      /**\n       * Determine weather the element has specific class name.\n       * @static\n       * @param {ObjectDOM} element \n       * @param {String} className \n       */\n      static hasClass(element, className){\n        if (element.classList)\n          return element.classList.contains(className);\n        else\n          return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n      }\n\n      /**\n       * Gets default values of configuration options.\n       * @static\n       * @return {Object} \n       */\n      static get defaults(){\n        return DEFAULTS;\n      }\n    }\n  \n    return StickySidebar;\n  })();\n  \n  export default StickySidebar;\n  \n  // Global\n  // -------------------------\n  window.StickySidebar = StickySidebar;"],"sourceRoot":""}